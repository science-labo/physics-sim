<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>レール上の球→円柱 衝突シミュレーター（3D＋グラフ3種）</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; line-height: 1.6; background-color: #f4f4f9; }
    .container { max-width: 1100px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      align-items: end;
    }
    .controls .row { display: flex; flex-direction: column; gap: 6px; }
    .btns { display:flex; gap:10px; flex-wrap: wrap; grid-column: 1 / -1; }
    button { padding: 10px 18px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; font-size: 16px; }
    button:hover { background-color: #0056b3; }
    .secondary { background-color: #6c757d; }
    .secondary:hover { background-color: #545b62; }

    #threeDContainer { width: 100%; height: 420px; background-color: #e0e0e0; border: 1px solid #ccc; margin-bottom: 16px; border-radius: 6px; overflow: hidden; }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      margin-bottom: 10px;
    }
    @media (min-width: 900px) {
      .charts { grid-template-columns: 1fr 1fr 1fr; }
    }
    .chart-card {
      border: 1px solid #e6e6e6;
      border-radius: 8px;
      padding: 10px 10px 6px;
      background: #fff;
    }
    .chart-title { font-weight: 700; margin: 4px 0 8px; font-size: 14px; }
    canvas { width: 100% !important; height: 260px !important; }

    .data-list { margin-top: 16px; font-size: 14px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; }
    .hint { color:#444; font-size: 14px; margin-top: 6px; }
    .mini { font-size: 12px; color:#666; }
  </style>
</head>
<body>
  <div class="container">
    <h2>レール上の球 → 円柱の衝突実験（3D＋グラフ）</h2>
    <p class="hint">
      質量と速さを設定して「衝突させる！」を押すと、<b>すぐに3つのグラフ</b>（速さ-距離 / 質量-距離 / エネルギー-距離）に点がプロットされ、3Dでレール上の衝突が見られます。
    </p>

    <div class="controls">
      <div class="row">
        <label>球の質量 (kg): <b><span id="massVal">5</span></b></label>
        <input type="range" id="mass" min="1" max="20" value="5" step="1" oninput="updateLabel('mass')">
        <div class="mini">※ 質量を変えたときの距離は「質量-距離」のグラフで確認</div>
      </div>

      <div class="row">
        <label>球の速さ (m/s): <b><span id="speedVal">5</span></b></label>
        <input type="range" id="speed" min="1" max="20" value="5" step="1" oninput="updateLabel('speed')">
        <div class="mini">※ 速さを変えたときの距離は「速さ-距離」のグラフで確認</div>
      </div>

      <div class="btns">
        <button onclick="addData()">衝突させる！</button>
        <button class="secondary" onclick="resetData()">データをリセット</button>
      </div>
    </div>

    <h3>3D：レール上で球が円柱に当たる</h3>
    <div id="threeDContainer"></div>

    <h3>グラフ（実験後すぐに点が追加されます）</h3>
    <div class="charts">
      <div class="chart-card">
        <div class="chart-title">① 速さ v (m/s) － 移動距離 (cm)</div>
        <canvas id="chartV"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">② 質量 m (kg) － 移動距離 (cm)</div>
        <canvas id="chartM"></canvas>
      </div>
      <div class="chart-card">
        <div class="chart-title">③ 運動エネルギー ½mv² － 移動距離 (cm)</div>
        <canvas id="chartE"></canvas>
      </div>
    </div>

    <div class="data-list">
      <h3>記録データ</h3>
      <table id="dataTable">
        <thead>
          <tr>
            <th>回数</th>
            <th>質量 (kg)</th>
            <th>速さ (m/s)</th>
            <th>速さの2乗 v²</th>
            <th>運動エネルギー ½mv²</th>
            <th>移動距離 (cm)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <p class="mini">
        ※ このサンプルでは「移動距離」は運動エネルギーに比例する簡易モデル（例：摩擦が一定）で計算しています。係数を入れたい場合は言ってください。
      </p>
    </div>
  </div>

<script>
  // ======================
  // 物理（簡易モデル）
  // ======================
  // 距離(cm) = (0.5*m*v^2) * K
  // Kは「表示しやすさ」の係数（摩擦などをまとめたイメージ）
  const K_DISTANCE = 0.5;

  // ======================
  // グラフ（Chart.js）
  // ======================
  let results = [];

  function makeScatterChart(canvasId, xLabel, yLabel) {
    const ctx = document.getElementById(canvasId).getContext("2d");
    return new Chart(ctx, {
      type: "scatter",
      data: {
        datasets: [{
          label: "実験結果",
          data: [],
          pointRadius: 5
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false, // すぐ反映させる
        scales: {
          x: { title: { display: true, text: xLabel } },
          y: { title: { display: true, text: yLabel }, beginAtZero: true }
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => `(${ctx.parsed.x.toFixed(2)}, ${ctx.parsed.y.toFixed(2)})`
            }
          }
        }
      }
    });
  }

  const chartV = makeScatterChart("chartV", "速さ v (m/s)", "移動距離 (cm)");
  const chartM = makeScatterChart("chartM", "質量 m (kg)", "移動距離 (cm)");
  const chartE = makeScatterChart("chartE", "運動エネルギー ½mv²", "移動距離 (cm)");

  function updateLabel(id) {
    document.getElementById(id + "Val").innerText = document.getElementById(id).value;
  }

  function addData() {
    const m = parseFloat(document.getElementById("mass").value);
    const v = parseFloat(document.getElementById("speed").value);

    const energy = 0.5 * m * (v * v);
    const distance = energy * K_DISTANCE; // cm

    const record = { m, v, energy, distance };
    results.push(record);

    // すぐ点をプロット（3種）
    chartV.data.datasets[0].data.push({ x: v, y: distance });
    chartM.data.datasets[0].data.push({ x: m, y: distance });
    chartE.data.datasets[0].data.push({ x: energy, y: distance });

    chartV.update();
    chartM.update();
    chartE.update();

    updateTable(record);

    // 3Dシミュレーション
    run3DCollision(m, v, distance);
  }

  function updateTable(r) {
    const tbody = document.querySelector("#dataTable tbody");
    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${results.length}</td>
      <td>${r.m}</td>
      <td>${r.v}</td>
      <td>${(r.v * r.v).toFixed(2)}</td>
      <td>${r.energy.toFixed(2)}</td>
      <td>${r.distance.toFixed(2)}</td>
    `;
    tbody.appendChild(row);
  }

  function resetData() {
    results = [];
    chartV.data.datasets[0].data = [];
    chartM.data.datasets[0].data = [];
    chartE.data.datasets[0].data = [];
    chartV.update(); chartM.update(); chartE.update();
    document.querySelector("#dataTable tbody").innerHTML = "";
    reset3DScene();
  }

  // ======================
  // 3D（Three.js）：レール＋球＋円柱
  // ======================
  let scene, camera, renderer;
  let ball, cylinder;
  let animationId = null;

  const track = {
    ballRadius: 1,
    cylRadius: 1.1,
    startX: -12,
    cylX: 0,
    yOnRail: 0.4
  };

  function init3D() {
    const container = document.getElementById("threeDContainer");

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 8, 18);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0x404040, 2));
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(10, 15, 8);
    scene.add(dir);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(60, 30);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x9a9a9a, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = Math.PI / 2;
    ground.position.y = -2;
    scene.add(ground);

    // Track base (板)
    const baseGeo = new THREE.BoxGeometry(40, 0.4, 6);
    const baseMat = new THREE.MeshLambertMaterial({ color: 0x6b4f2a });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(2, -1.2, 0);
    scene.add(base);

    // Rails（2本）
    const railGeo = new THREE.BoxGeometry(40, 0.25, 0.25);
    const railMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
    const rail1 = new THREE.Mesh(railGeo, railMat);
    const rail2 = new THREE.Mesh(railGeo, railMat);
    rail1.position.set(2, -0.9, 1.2);
    rail2.position.set(2, -0.9, -1.2);
    scene.add(rail1, rail2);

    // Sleepers（枕木っぽい）
    const sleeperGeo = new THREE.BoxGeometry(0.8, 0.15, 3.2);
    const sleeperMat = new THREE.MeshLambertMaterial({ color: 0x4a3a22 });
    for (let i = -16; i <= 18; i += 2) {
      const s = new THREE.Mesh(sleeperGeo, sleeperMat);
      s.position.set(i, -1.05, 0);
      scene.add(s);
    }

    // Ball（球）
    const ballGeo = new THREE.SphereGeometry(track.ballRadius, 32, 32);
    const ballMat = new THREE.MeshLambertMaterial({ color: 0xff3b3b });
    ball = new THREE.Mesh(ballGeo, ballMat);
    ball.position.set(track.startX, track.yOnRail, 0);
    scene.add(ball);

    // Cylinder（円柱：当てられる物体）
    const cylGeo = new THREE.CylinderGeometry(track.cylRadius, track.cylRadius, 2.2, 32);
    const cylMat = new THREE.MeshLambertMaterial({ color: 0x2f6bff });
    cylinder = new THREE.Mesh(cylGeo, cylMat);
    cylinder.position.set(track.cylX, 0.1, 0);
    scene.add(cylinder);

    // Resize
    window.addEventListener("resize", onWindowResize, false);

    render3D();
  }

  function onWindowResize() {
    const container = document.getElementById("threeDContainer");
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
    render3D();
  }

  function render3D() {
    renderer.render(scene, camera);
  }

  function run3DCollision(mass, speed, distanceCm) {
    if (animationId) cancelAnimationFrame(animationId);

    // reset positions
    ball.position.set(track.startX, track.yOnRail, 0);
    ball.rotation.set(0, 0, 0);
    cylinder.position.set(track.cylX, 0.1, 0);
    cylinder.material.color.set(0x2f6bff);

    // 見た目用スケール
    const speedScale = 0.75 + speed * 0.10;     // 速さ → 進む速さ
    const distScale = 1 / 35;                   // cm → Three.js単位
    const maxDisplacement = 10;                 // 画面外に飛ばないための上限

    const targetDisplacement = Math.min(distanceCm * distScale, maxDisplacement);

    const hitX = cylinder.position.x - (track.ballRadius + track.cylRadius);
    let lastX = ball.position.x;
    let startTime = null;

    function animate(t) {
      if (!startTime) startTime = t;
      const dt = (t - startTime) / 1000;

      // Ball move
      const newX = track.startX + (dt * speedScale * 8); // 係数8で見やすく
      ball.position.x = newX;

      // rolling rotation（x方向に進むので z軸回転）
      const dx = newX - lastX;
      ball.rotation.z -= dx / track.ballRadius;
      lastX = newX;

      // collision
      if (ball.position.x >= hitX) {
        // cylinder moves after impact
        cylinder.position.x = track.cylX + targetDisplacement;

        // flash effect
        cylinder.material.color.set(0xffd500);
        setTimeout(() => cylinder.material.color.set(0x2f6bff), 200);

        render3D();
        animationId = null;
        return;
      }

      render3D();
      animationId = requestAnimationFrame(animate);
    }

    animationId = requestAnimationFrame(animate);
  }

  function reset3DScene() {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    if (ball && cylinder) {
      ball.position.set(track.startX, track.yOnRail, 0);
      ball.rotation.set(0, 0, 0);
      cylinder.position.set(track.cylX, 0.1, 0);
      cylinder.material.color.set(0x2f6bff);
      render3D();
    }
  }

  window.onload = init3D;
</script>
</body>
</html>

